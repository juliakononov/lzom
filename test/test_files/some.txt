// SPDX-License-Identifier: GPL-2.0-only

#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/blkdev.h>
#include <linux/blk_types.h>

#include "lzom.h"

#define LZOM_NAME "lzo_module"
#define LZOM_INIT_MINOR 0
#define POOL_SIZE 512

#define LZOM_LOG(fmt, ...) \
    pr_info("%s[inf] " fmt "\n", LZOM_NAME, ##__VA_ARGS__)

#define LZOM_ERRLOG(fmt, ...) \
    pr_err("%s[err] " fmt "\n", LZOM_NAME, ##__VA_ARGS__)

static struct lzom_module_g lzom = {.free_minor = LZOM_INIT_MINOR};

static bool lzom_is_exist(void)
{
    return lzom.dev_path;
}

/* ----------------- submit bio -----------------*/

static void lzom_req_free(struct lzom_req *lreq)
{
    if (!lreq)
        return;

    kfree(lreq);
}

static struct lzom_req *lzom_req_alloc(void)
{
    struct lzom_req *lreq;

    lreq = kzalloc(sizeof(*lreq), GFP_NOIO);
    if (!lreq) {
        LZOM_ERRLOG("failed to allocate request");
        return NULL;
    }

    return lreq;
}

static void lzom_write_req_endio(struct bio *bio)
{
    struct lzom_req *lreq = bio->bi_private;
    struct bio *original_bio = lreq->original_bio;

    bio_endio(original_bio);

    bio_put(bio);
    lzom_req_free(lreq);
}

static void lzom_read_req_endio(struct bio *bio)
{
    struct lzom_req *lreq = bio->bi_private;
    struct bio *original_bio = lreq->original_bio;

    bio_endio(original_bio);

    bio_put(bio);
    lzom_req_free(lreq);
}

static blk_status_t lzom_write_req_submit(struct lzom_req *lreq, struct bio *original_bio, struct lzom_dev *ldev)
{
    struct block_device *bdev = ldev->under_dev.bdev;
    struct bio_set *bset = ldev->under_dev.bset;
    struct bio *new_bio;

    new_bio = bio_alloc_clone(bdev, original_bio, GFP_NOIO, bset);
    if (!new_bio) {
        LZOM_ERRLOG("failed to clone original bio");
        return BLK_STS_RESOURCE;
    }

    // new_bio->bi_vcnt = original_bio->bi_vcnt;
    new_bio->bi_end_io = lzom_write_req_endio;
    new_bio->bi_private = lreq;
    new_bio->bi_iter.bi_sector = original_bio->bi_iter.bi_sector;

    lreq->original_bio = original_bio;
    lreq->new_bio = new_bio;

    submit_bio_noacct(new_bio);

    return BLK_STS_OK;
}

static blk_status_t lzom_read_req_submit(struct lzom_req *lreq, struct bio *original_bio, struct lzom_dev *ldev)
{
    struct block_device *bdev = ldev->under_dev.bdev;
    struct bio_set *bset = ldev->under_dev.bset;
    struct bio *new_bio;

    new_bio = bio_alloc_clone(bdev, original_bio, GFP_NOIO, bset);
    if (!new_bio) {
        LZOM_ERRLOG("failed to clone original bio");
        return BLK_STS_RESOURCE;
    }

    new_bio->bi_end_io = lzom_read_req_endio;
    new_bio->bi_private = lreq;
    new_bio->bi_iter.bi_sector = original_bio->bi_iter.bi_sector;

    lreq->original_bio = original_bio;
    lreq->new_bio = new_bio;

    submit_bio_noacct(new_bio);

    return BLK_STS_OK;
}

static void lzom_submit_bio(struct bio *original_bio)
{
    struct lzom_dev *ldev = original_bio->bi_bdev->bd_disk->private_data;
    struct lzom_req *lreq;
    enum req_op op_type = bio_op(original_bio);

    if (!ldev || !ldev->under_dev.bdev) {
        LZOM_ERRLOG("invalid device context");
        goto submit_bio_with_err;
    }

    // if (original_bio->bi_iter.bi_size != SUPPORTED_BS)
    // {
    //     /* TODO: чет не пон
    //     TODO:(#MINDIT) [ implemetation features, SUPPORTED_BS ]
    //         current implementation of READ and WRITE correctly works only while
    //         * original_bio->bi_iter.bi_size == SUPPORTED_BS
    //         * SUPPORTED_BS == req->ldev->block_size
    //     */
    //     LZOM_ERRLOG("unsupported block size: %u (expected: %u)",
    //                 original_bio->bi_iter.bi_size, SUPPORTED_BS);
    //     goto submit_bio_with_err;
    // }

    lreq = lzom_req_alloc();
    if (!lreq) {
        goto submit_bio_with_err;
    }

    switch (op_type) {
        case REQ_OP_WRITE:
            if (lzom_write_req_submit(lreq, original_bio, ldev) == BLK_STS_OK)
                return;
            goto submit_bio_with_err_free_req;

        case REQ_OP_READ:
            if (lzom_read_req_submit(lreq, original_bio, ldev) == BLK_STS_OK)
                return;
            goto submit_bio_with_err_free_req;

        default:
            LZOM_ERRLOG("unsupported request operation");
            goto submit_bio_with_err;
    }

submit_bio_with_err:
    bio_io_error(original_bio);
submit_bio_with_err_free_req:
    lzom_req_free(lreq);
    bio_io_error(original_bio);
}



static const struct block_device_operations lzom_fops = {
    .owner = THIS_MODULE,
    .submit_bio = lzom_submit_bio,
};

static int lzom_new_minor_get(void)
{
    return lzom.free_minor++;
}

static void lzom_dev_unregister(struct lzom_dev *ldev)
{
    del_gendisk(ldev->disk);
    put_disk(ldev->disk);
    ldev->disk = NULL;
    LZOM_LOG("disk unregistered successfully");
}

static int lzom_dev_register(int major, int minor, struct lzom_dev *ldev)
{
    struct gendisk *disk = ldev->disk;

    if (!disk) {
        LZOM_ERRLOG("attempt to register NULL disk");
        return -EINVAL;
    }

    disk->major = major;
    disk->first_minor = minor;
    disk->minors = 1;
    disk->fops = &lzom_fops;
    disk->private_data = ldev;

    disk->flags |= GENHD_FL_NO_PART;

    set_capacity(disk, get_capacity(ldev->under_dev.bdev->bd_disk));

    snprintf(disk->disk_name, DISK_NAME_LEN, "lzom%d", disk->first_minor);
    
    return add_disk(ldev->disk);
}

static void lzom_dev_deinit(struct lzom_dev *ldev)
{
    if (ldev->disk)
        put_disk(ldev->disk);

    if (ldev->under_dev.bset) {
        bioset_exit(ldev->under_dev.bset);
        kfree(ldev->under_dev.bset);
    }

    LZOM_LOG("device deinitialized");
}

static int lzom_dev_init(const char *path, struct lzom_dev *ldev)
{
    struct file *fbdev;
    struct block_device *bdev;
    struct bio_set *bset;

    memset(ldev, 0, sizeof(*ldev));

    fbdev = bdev_file_open_by_path(
        path, BLK_OPEN_READ | BLK_OPEN_WRITE, &ldev->under_dev, NULL);
    if (IS_ERR(fbdev)) {
        LZOM_ERRLOG("failed to open device path '%s'", path);
        return PTR_ERR(fbdev);
    }

    bdev = file_bdev(fbdev);

    ldev->under_dev.bdev = bdev;
    ldev->under_dev.bdev_fl = fbdev;

    bset = kzalloc(sizeof(*bset), GFP_KERNEL);
    if (!bset) {
        LZOM_ERRLOG("failed to allocate memory for bioset");
        goto err;
    }

    bioset_init(bset, POOL_SIZE, 0, BIOSET_NEED_BVECS);
    ldev->under_dev.bset = bset;
    LZOM_LOG("bioset initialized");

    ldev->disk = blk_alloc_disk(NULL, NUMA_NO_NODE);
    if (!ldev->disk) {
        LZOM_ERRLOG("failed to allocate disk");
        goto err;
    }

    LZOM_LOG("device initialized");
    return 0;

err:
    lzom_dev_deinit(ldev);
    return -ENOMEM;
}

static void lzom_path_remove(void)
{
    if (!lzom_is_exist()) {
        LZOM_ERRLOG("no device path to remove");
        return;
    }

    kfree(lzom.dev_path);
    lzom.dev_path = NULL;
    LZOM_LOG("device path removed");
}

static int lzom_path_set(const char *arg, struct lzom_module_g *lzom)
{
    size_t len = strlen(arg) + 1;

    BUG_ON(lzom->dev_path);

    lzom->dev_path = kzalloc(sizeof(char) * len, GFP_KERNEL);
    if (!lzom->dev_path) {
        LZOM_ERRLOG("failed to allocate memory for device path: %lu bytes", len);
        return -ENOMEM;
    }

    strcpy(lzom->dev_path, arg);
    LZOM_LOG("device path set: %s", lzom->dev_path);
    return 0;
}

static void lzom_blk_destroy(void)
{
    if (!lzom_is_exist()) {
        LZOM_ERRLOG("no device for unmapping");
        return;
    }
  
    lzom_dev_unregister(&lzom.dev);
    lzom_dev_deinit(&lzom.dev);

    LZOM_LOG("device unmapped");
}

static int lzom_blk_create(const char *arg, const struct kernel_param *kp)
{
    int ret = 0;

    if (lzom_is_exist()) {
        LZOM_ERRLOG("device already exists");
        return -EACCES;
    }

    ret = lzom_path_set(arg, &lzom);
    if (ret)
        goto err;

    ret = lzom_dev_init(lzom.dev_path, &lzom.dev);
    if (ret)
        goto err;

    LZOM_LOG("device initialized");

    ret = lzom_dev_register(lzom.major, lzom_new_minor_get(), &lzom.dev);
    if (ret)
        goto err;

    LZOM_LOG("device